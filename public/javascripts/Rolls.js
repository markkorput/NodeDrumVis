// Generated by CoffeeScript 1.6.3
(function() {
  var StatsView;

  StatsView = Backbone.View.extend({
    tagName: 'div',
    className: 'RollsStats',
    initialize: function(opts) {
      var _this = this;
      this.analyser = opts.analyser;
      this.listenTo(this.collection, 'change', this.render);
      return Object.observe(this.analyser.values, function(changes) {
        if (changes[0].name === 'time') {
          return _this.render();
        }
      });
    },
    render: function() {
      this.$el.html('');
      if (this.analyser) {
        this.$el.append('<span>Time: ' + this.analyser.values.time + '</span>');
      }
      this.$el.append('<span>Number of hits: ' + this.collection.length + '</span>');
      if (this.analyser) {
        this.$el.append('<span>Last BPM: ' + this.analyser.values.lastNoteBpm + '</span>');
      }
      if (this.analyser) {
        return this.$el.append('<span>Current BPM: ' + this.analyser.values.currentBpm + '</span>');
      }
    }
  });

  this.Rolls = (function() {
    function Rolls(_opts) {
      var folder, mat,
        _this = this;
      this.options = _opts;
      this.camera = _opts.camera;
      this.scene = _opts.scene;
      this._notes = _opts.notes;
      this.colors = _.map(Please.make_color({
        colors_returned: 2
      }), function(clr) {
        return new THREE.Color(clr);
      });
      this.statsView = new StatsView({
        collection: this._notes,
        analyser: _opts.analyser
      });
      $('body').append(this.statsView.el);
      this.config = {
        enabled: true,
        startX: -60,
        startY: 30,
        startZ: -50,
        maxX: 20,
        speed: 20,
        stepY: -1.5,
        minY: -30,
        cursor: true
      };
      if (this.options.gui) {
        this.options.gui.remember(this.config);
        folder = this.options.gui.addFolder('Rolls');
        _.each(Object.keys(this.config), function(key) {
          var item;
          return item = folder.add(_this.config, key);
        });
        _.find(folder.__controllers, function(cont) {
          return cont.property === 'cursor';
        }).onChange(function(cursorEnabled) {
          if (!_this._cursorMesh) {
            return;
          }
          if (cursorEnabled) {
            return _this.scene.add(_this._cursorMesh);
          } else {
            return _this.scene.remove(_this._cursorMesh);
          }
        });
      }
      this._material = new THREE.LineBasicMaterial();
      this._material.color = this.colors[0];
      this._geometry = new THREE.PlaneGeometry(1, 1);
      this.cursor = new THREE.Vector3(this.config.startX, this.config.startY, this.config.startZ);
      this.camera.position.set(0, 0, 0);
      this._notes.on('add', function(note) {
        var mesh;
        mesh = _this.add(note.get('note'), 1.0);
        return note.set({
          rollsMesh: mesh
        });
      });
      this._notes.on('remove', function(note) {
        return _this.scene.remove(note.get('rollsMesh'));
      });
      this._notes.on('reset', function(collection, options) {
        _.each(options.previousModels, function(note) {
          _this.scene.remove(note.get('rollsMesh'));
          return note.unset('rollsMesh');
        });
        _this.cursor.set(_this.config.startX, _this.config.startY, _this.config.startZ);
        return _this.camera.position.set(0, 0, 0);
      });
      mat = new THREE.LineBasicMaterial();
      mat.color = this.colors[1];
      this._cursorMesh = new THREE.Mesh(this._geometry, mat);
      this._cursorMesh.position.copy(this.cursor);
      if (this.config.cursor) {
        this.scene.add(this._cursorMesh);
      }
    }

    Rolls.prototype.add = function(kind, volume) {
      var mesh;
      if (this.config.enabled !== true) {
        return;
      }
      mesh = new THREE.Mesh(this._geometry, this._material);
      mesh.position.copy(this.cursor);
      this.scene.add(mesh);
      return mesh;
    };

    Rolls.prototype.update = function(dt) {
      var dx, dy;
      if (this.config.enabled !== true) {
        return;
      }
      this.cursor.x = this.cursor.x + this.config.speed * dt;
      dx = this.cursor.x - this.config.maxX;
      if (dx > 0) {
        this.cursor.x = this.config.startX + dx;
        this.cursor.y += this.config.stepY;
        dy = this.cursor.y - this.camera.position.y;
        if (dy < this.config.minY) {
          this.camera.position.y = this.cursor.y - this.config.minY;
        }
      }
      return this._cursorMesh.position.copy(this.cursor);
    };

    Rolls.prototype.log = function(msg) {
      var prefix;
      prefix = 'Rolls';
      if (arguments.length === 1) {
        console.log(prefix, msg);
        return;
      }
      if (arguments.length === 2) {
        console.log(prefix, msg, arguments[1]);
        return;
      }
      if (arguments.length === 3) {
        console.log(prefix, msg, arguments[1], arguments[2]);
        return;
      }
      return console.log(prefix, msg, arguments[1], arguments[2], arguments[3]);
    };

    Rolls.prototype.removeTiles = function() {
      var _this = this;
      return this._notes.each(function(note) {
        var m;
        if (m = note.get('rollsMesh')) {
          _this.scene.remove(m);
          return note.unset('rollsMesh');
        }
      });
    };

    return Rolls;

  })();

}).call(this);
